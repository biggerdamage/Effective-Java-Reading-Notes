# Chapter 8 方法
## 第38条 检查参数的有效性
方法的参数限制, 应该在文档中指明, 并且在方法体的开头处检查参数, 以强制施加这些限制.

对于公有的方法, 要用Javadoc的`@throws`标签在文档中说明违反参数值限制时会抛出的异常.

非公有的方法通常应该使用断言(assertion)来检查它们的参数. 如果断言失败会抛出AssertionError, 如果它们没有起到作用, 本质上也不会有成本开销. (除非通过将-ea或者-enableassertions标记传递给Java解释器来启用它们.)

## 第39条 必要时进行保护性拷贝
你的类是否能够容忍对象进入数据结构之后发生变化? 如果答案是否定的, 就必须对该对象进行保护性拷贝, 并且让拷贝之后的对象而不是原始对象进入到数据结构中.

在内部组件被返回给客户端之前, 对它们进行保护性拷贝也是同样的道理.

只要有可能, 都应该使用不可变的对象作为对象内部的组件, 这样就不必再为保护性拷贝操心.

如果拷贝的成本受到限制, 并且类信任它的客户端不会不恰当地修改组件, 就可以在文档中指明客户端的职责是不得修改受到影响的组件, 以此来代替保护性拷贝.

## 第40条 谨慎设计方法签名
API设计技巧:
* 谨慎选择方法名.
* 不要过于追求提供便利的方法.
* 避免过长的参数列表. -> 1.分解成多个方法; 2.创建辅助类, 用来保存参数的分组; 3.从对象构建到方法调用都采用Builder模式.
* 参数类型优先使用接口而不是类.
* 对于boolean参数, 要优先使用两个元素的枚举类型.

## 第41条 慎用重载
对于重载(overload)方法的选择是静态的, 而对于被覆盖(override)方法的选择则是动态的.

选择被覆盖方法的正确版本是在运行时进行的, 选择的依据是被调用方法所在对象的运行时类型.
所以子类方法与基类签名相同, 则覆盖基类, 尽管对象声明为基类, 但是调用时用的是子类的实现.

但重载的选择工作是在编译时进行的, 完全基于参数的编译时类型. 这样的代码很容易使人感到困惑.

安全而保守的策略是: 永远不要导出两个具有相同参数数目的重载方法. 如果方法使用可变参数(varargs), 保守的策略是不要重载它.

这项限制并不麻烦, 因为你始终可以给方法起不同的名称而不使用重载机制.

对于构造器, 没有选择不同名称的机会, 在许多情况下, 可以选择导出静态工厂.

当然如果对于每一种重载方法, 至少有一个对应的参数在两个重载方法中具有根本不同的类型, 就不会产生迷惑. 在这种情况下主要的混淆根源就消除了.

## 第42条 慎用可变参数
可变参数机制通过先创建一个数组, 数组的大小为在调用位置所传递的参数数量, 然后将参数传到数组中, 最后将数组传递给方法.

在重视性能的情况下, 使用可变参数机制要特别小心.

在定义参数数目不定的方法时, 可变参数是一种很方便的方式, 但是它们不应该被过度滥用.

## 第43条 返回零长度的数组或集合, 而不是null
返回类型为数组或集合的方法没理由返回null, 而不是返回一个零长度的数组或者集合.

开销考虑:
* 在这个级别上担心性能问题是不明智的, 除非分析表明这个方法是造成性能问题的真正源头.
* 对于不返回任何元素的调用, 每次都返回同一个零长度数组是有可能的. (例如: `Collections.emtpySet`).

## 第44条 为所有导出的API元素编写文档注释
Javadoc可以根据源代码自动生成API文档.

方法的文档注释应该简洁地描述出它和客户端之间的约定. 这个约定应该说明这个方法做了什么, 而不是如何完成这项工作的.

方法的文档注释还应该列举出:
* 所有前提条件. 一般可以利用`@throws`, `@param`.
* 后置条件.
* 副作用.
* 线程安全性.
* 每个参数: `@param` 名词短语.
* 返回值: `@return` 名词短语.
* 每个异常: `@throws` 含if的名词短语. 


按惯例, `@param`, `@return`, `@throws`后面的短语或句子都不用句点来结束.

每个文档注释的第一句话成了该注释所属元素的概要描述. 对于方法和构造器而言, 概要描述应该是个完整的动词短语, 它描述了该方法所执行的动作. 对于类, 接口和域, 概要描述应该是一个名词短语.
