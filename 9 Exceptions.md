# Effective Java笔记八 异常
## 第57条 只针对异常的情况才使用异常
异常应该只用于异常的情况下, 永远不应该用于正常的控制流. 

良好设计的API不应该强迫它的客户端为了正常的控制流而使用异常.

如果类具有状态相关(state-dependent)的方法, 往往也应该有个状态测试(state-testing)方法.
举例: `Iterator`接口的`next()`方法状态相关, 相应的测试方法是`hasNext()`.

另一种状态测试的做法: 让状态相关的方法返回一个可识别的值, 比如null.
(对`next()`不适用, 因为null是`next()`方法的合法返回值.)

## 第58条 对可恢复的情况使用受检异常, 对编程错误使用运行时异常
Java提供三种可抛出结构(throwable):
* 受检异常(checked exception).
* 运行时异常(run-time exception).
* 错误(error).

决定使用受检异常或是非受检异常时, 主要的原则: 如果期望调用者能够适当地恢复, 对于这种情况就应该使用受检的异常.

通过抛出受检的异常, 强迫调用者在一个catch子句中处理该异常, 或者将它传播出去. 每个受检异常都是对API用户的一个潜在指示: 与异常相关联的条件是这个方法的一种可能的结果.

用运行时异常来表明编程错误. 大多数运行时异常都表示前提违例, 例如数组越界访问.

虽然Java语言规范没有要求, 但是按照惯例, 错误往往被JVM保留用于表示资源不足, 约束失败或者其他使程序无法继续执行的条件.
因此, 你实现的所有未受检的抛出结构都应该是`RuntimeException`的子类.

## 第59条 避免不必要地使用受检的异常
受检的异常强迫程序员处理异常的情况, 大大增强了可靠性.

如果方法抛出一个或多个受检的异常, 调用该方法的代码就必须在一个或多个catch块中处理这些异常, 或者它必须声明抛出这些异常.

但是过分使用受检的异常会使API使用起来非常不方便.

如果正确地使用API并不能阻止这种异常条件的产生, 并且一旦产生异常, 使用API的程序员可以立即采取有用的动作, 这种负担就被认为是正当的.

"把受检的异常变成未受检的异常"的一种方法是, 把这个抛出异常的方法分成两个方法, 其中第一个方法返回一个boolean, 表明是否该抛出异常. -> 状态测试方法.

## 第60条 优先使用标准的异常
常用的异常:
* `IllegalArgumentException`
* `IllegalStateException`
* `NullPointerException`
* `IndexOutOfBoundsException`
* `ConcurrentModificationException`
* `UnsupportedOperationException`

## 第61条 抛出与抽象相对应的异常
异常转译(exception translation): 更高层的实现应该捕获底层的异常, 同时抛出可以按照高层抽象进行解释的异常.

异常链(exception chaining): 如果低层的异常对于调试导致高层异常的问题非常有帮助, 使用异常链将低层的异常(原因cause)传到高层.

大多数标准的异常都有支持链的构造器, 对于没有的, 可以用`Throwable.initCause()`设置原因.

## 第62条 每个方法抛出的异常都要有文档
始终要单独地声明受检的异常, 并且利用Javadoc的`@throws`标记, 准确地记录下抛出每个异常的条件.

虽然Java并不要求方法声明它可能会抛出的未受检异常, 但是仔细地为未受检异常建立文档是非常明智的, 因为它们有效描述了方法的前提条件.

在方法的声明中, 需要把每个受检异常都单独throws, 但是不要把非受检异常包含在方法声明中.

## 第63条 在细节消息中包含能捕获失败的信息
程序由于未被捕获的异常失败的时候, 会打印该异常的堆栈轨迹, 包含该异常的`toString()`结果: 通常包含类名和细节消息(detail message).

异常的细节信息应该包含对该异常有贡献的参数和域的值.

为了确保在异常的细节消息中包含足够的信息, 一种办法是在异常的构造器中引入这些信息, 然后只要把它们放到消息描述中, 就可以自动产生细节信息.

## 第64条 努力使失败保持原子性
失败原子性(failure atomic): 失败的方法调用应该使对象保持在被调用之前的状态.

实现这种效果的途径:
* 设计一个不可变的对象.
* 在执行操作之前检查参数的有效性, 在对象的状态被修改之前抛出适当的异常. -> 让可能会失败的计算部分都在对象状态被修改之前发生.
* 编写一段恢复代码, 使对象回滚.
* 在对象的一份临时拷贝上执行操作, 当操作完成后再用临时拷贝中的结果代替对象的内容.

## 第65条 不要忽略异常
空的catch块会使异常达不到应有的目的. -> 至少应该有个说明吧.
